\documentclass[a4paper,12pt]{article}

%% Начало шапки

%% Настройка поддержки русского языка
\usepackage{cmap}                   % Поиск по кириллице
\usepackage{mathtext}               % Кириллица в формулах
\usepackage[T1,T2A]{fontenc}        % Кодировки шрифтов
\usepackage[utf8]{inputenc}         % Кодировка текста
\usepackage[english,russian]{babel} % Подключение поддержки языков

%% Настройка размеров полей
\usepackage[top=0.7in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}

%% Математические пакеты
\usepackage{mathtools}              % Тот же amsmath, только с некоторыми поправками
\usepackage{amssymb}                % Математические символы
\usepackage{amsthm}                 % Оформление теорем
\usepackage{amstext}                % Текстовые вставки в формулы
\usepackage{amsfonts}               % Математические шрифты
\usepackage{icomma}                 % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{enumitem}               % Для выравнивания itemize (\begin{itemize}[align=left])
\usepackage{array}                  % Таблицы и матрицы
\usepackage{multirow}

%% Алгоритмические пакеты и их настройки
\usepackage{algorithm}              % Шапка алгоритма
\usepackage{algorithmicx}           % Написание алгоритмов
\usepackage[noend]{algpseudocode}   % Написание псевдокода; убраны end
\usepackage{listings}               % Для кода на каком-либо языке программиования
\renewcommand{\algorithmicrequire}{\textbf{Ввод:}}              % Ввод
\renewcommand{\algorithmicensure}{\textbf{Вывод:}}              % Вывод
\floatname{algorithm}{Алгоритм}                                 % Название алгоритма
\renewcommand{\algorithmiccomment}[1]{\hspace*{\fill}\{// #1\}} % Комментарии
\newcommand{\algname}[1]{\textsc{#1}}                           % Вызов функции в алгоритме

\newcommand*{\hm}[1]{#1\nobreak\discretionary{}
	{\hbox{$\mathsurround=0pt #1$}}{}}

%% Шрифты
\usepackage{euscript}               % Шрифт Евклид
\usepackage{mathrsfs}               % \mathscr{}

%% Графика
\usepackage[pdftex]{graphicx}       % Вставка картинок
\graphicspath{{images/}}            % Стандартный путь к картинкам
\usepackage{tikz}                   % Рисование всего
\usepackage{pgfplots}               % Графики
\usetikzlibrary{calc,matrix}

%% Прочие пакеты
\usepackage{indentfirst}                    % Красная строка в начале текста
\usepackage{epigraph}                       % Эпиграфы
\usepackage{fancybox,fancyhdr}              % Колонтитулы
\usepackage[colorlinks=true, urlcolor=blue]{hyperref}   % Ссылки
\usepackage{titlesec}                       % Изменение формата заголовков
\usepackage[normalem]{ulem}                 % Для зачёркиваний
\usepackage[makeroom]{cancel}               % И снова зачёркивание (на этот раз косое)

%% Прочее
\mathtoolsset{showonlyrefs=true}        % Показывать номера только у тех формул,
% на которые есть \eqref{} в тексте.
\renewcommand{\headrulewidth}{1.8pt}    % Изменяем размер верхнего отступа колонтитула
\renewcommand{\footrulewidth}{0.0pt}    % Изменяем размер нижнего отступа колонтитула

%Прочее
\usepackage{forest} % Деревья

\renewcommand{\Re}{\mathrm{Re\:}}
\renewcommand{\Im}{\mathrm{Im\:}}
\newcommand{\Arg}{\mathrm{Arg\:}}
\renewcommand{\arg}{\mathrm{arg\:}}
\newcommand{\Mat}{\mathrm{Mat}}
\newcommand{\M}{\mathrm{M}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\isom}{\xrightarrow{\sim}} 
\newcommand{\leftisom}{\xleftarrow{\sim}}
\newcommand{\Hom}{\mathrm{Hom}}
\newcommand{\Ker}{\mathrm{Ker}\:}
\newcommand{\rk}{\mathrm{rk}\:}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\ort}{\mathrm{ort}}
\newcommand{\pr}{\mathrm{pr}}
\newcommand{\vol}{\mathrm{vol\:}}
\newcommand{\Tr}{\mathrm{tr\:}}
\newcommand{\sgn}{\mathrm{sgn\:}}
\newcommand{\al}{\alpha}

%% Определения
\newtheorem{definition}{Определение}
\newtheorem{ther}{Теорема}
\newtheorem*{defin}{Определение}
\newtheorem{Def}{Определение}
\newtheorem*{Lemma}{Лемма}
\newtheorem{Suggestion}{Предложение}
\newtheorem*{Examples}{Пример}
\newtheorem*{Consequence}{Следствие}
\newtheorem{Theorem}{Теорема}
\newtheorem{Statement}{Утверждение}
\newtheorem*{Task}{Упражнение}
\newtheorem*{Designation}{Обозначение}
\newtheorem*{Generalization}{Обобщение}
\newtheorem*{Thedream}{Предел мечтаний}
\newtheorem*{Properties}{Свойства}
\newtheorem*{Note}{Замечание}

\newtheorem*{Induction_def} {Принцип математической индукции}
\newtheorem*{Full_induction_def} {Принцип полной математической индукции}
\newtheorem*{Evc} {Алгорим Евклида}
\newtheorem*{state}{Утверждение}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\renewcommand{\C}{\mathbb{C}}
\renewcommand{\L}{\mathscr{L}}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\newcommand{\e}{\mathbb{e}}
\renewcommand{\l}{\lambda}
\newcommand{\E}{\mathbb{E}}
\def\eps{\varepsilon}
\def\limref#1#2{{#1}\negmedspace\mid_{#2}}
\newcommand{\vvector}[1]{\begin{pmatrix}{#1}_1 \\\vdots\\{#1}_n\end{pmatrix}}
\renewcommand{\vector}[1]{({#1}_1, \ldots, {#1}_n)}

\definecolor{Gray}{gray}{0.9}
\newcolumntype{g}{>{\columncolor{Gray}}c}

\newtheorem*{canonther}{Теорема о приведении матрицы к каноническому виду}
\newtheorem*{lem}{Лемма}
\newtheorem*{lem1}{Лемма 1}
\newtheorem*{lem2}{Лемма 2}
\newtheorem*{lem3}{Лемма 3}

\newcommand{\p}{^{\prime}}

\begin{document}
	\title{Материалы для подготовки к коллоквиуму\\ по дискретной математике \\
	Теоремы}
	\author{ПМИ 2016 \\ Орлов Никита, Рубачев Иван, Ткачев Андрей, Евсеев Борис}
	\maketitle
	
	\section*{}

	
	\begin{center}
		\line(1,0){450}
	\end{center}

	\section*{1. Вывод принципа полной математической индукции из принципа математической индукции}

	\begin{Induction_def}
		Если для утверждения зависящего от положительного натурального $n$ выполняются следущие условия:
		\begin{itemize}
			\item 1. Утверждение истинно при $n = 1$
			\item 2. Когда утверждение истинно при $n = k$, оно истинно и при $n = k + 1$
		\end{itemize}
		Тогда утверждение истинно при всех положительных $n$.
	\end{Induction_def}

	\begin{Full_induction_def}
		Если для утверждения зависящего от положительного натурального $n$ выполняются следущие условия:
		\begin{itemize}
			\item 1. Утверждение истинно для $n = 1$
			\item 2. Если утверждение истинно для всех $n \leqslant k$, оно также истинно и для $n = k + 1$
		\end{itemize}
		Тогда утверждение истинно при всех положительных $n$.
	\end{Full_induction_def}
	\begin{state} 
		Если уместна математическая индукция, то уместна и сильная индукция.
	\end{state}
	\begin{proof}
		В дальньейших рассуждениях будем считать, что $n$ - натуральное, большее или равное $1$, а также обозначим утверждение зависящее от $n$ за $\phi(n)$.

		Предположим, что для $\phi(n)$ выполняются условия $(1)$ и $(2)$ для сильной индукции.

		Пусть $\psi(k) \Leftrightarrow $ <<$\phi(n)$ истинно для всех $n \leqslant k$>>.

		Попытаемся доказать, что утверждение $\psi(n)$ истинно для всех положительных натуральных $n$ по индукции. Как следствие, мы получим, что и $\phi(n)$ верно для всех положительных $n$, т.е. тот же вывод, который должен дать принцип сильной индукции.

		\textit{База}. В силу нашего предположения $\phi(1)$ истинно (гипотеза $(1)$ сильной индукции верна), но тогда истинно и $\psi(1)$, по опеределению $\psi(n)$.

		\textit{Предположение}. Пусть верно $\psi(k)$.

		\textit{Шаг}. Мы предположили, что для $\phi(n)$ выполняются гипотезы сильной индукции, а значит, если <<$\phi(n)$ верно для всех $n \leqslant k$>>, то и $\phi(k + 1)$ - верно. По предположению индукции - $\psi(k) \Rightarrow \phi(k + 1)$ (см. определение $\psi(n)$ и гипотезу $(2)$ сильной индукции). Получаем, что $\psi(k + 1)$ - истинно, т.к. $\phi(n)$ истинно для всех $n \leqslant k + 1$ $\Rightarrow$ $\psi(k + 1)$.

		Согласно принципу мат. индукции $\psi(k)$ - верно для всех положительных $k$, занчит утверждение <<$\phi(n)$ истинно для всех $n \leqslant k$>> верно при всех $k$, а значит $\phi(n)$ - верно для всех $n$.

		Таким образом, из принципа мат. индукции следует принцип полной мат. индукциию.  
 	\end{proof}

 	\section*{2. Бином Ньютона. Формула для биномиальных коэффициентов}
    Число сочетаний из $n$ по $k$ равно:
    \[
        \binom{n}{k} = \frac{n!}{k!(n - k)!}
    \]
    \begin{proof}
        На первое место можно поставить любой из $n$ элементов, на второе любой из $n - 1$ оставшихся, $\ldots$, на $k$-е любой из $n - k + 1$. Тогда по правилу произведения существует $n(n - 1)(n - 2)\cdots(n - k + 1)$ упорядоченных наборов. Но порядок нам не важен, поэтому существует $\displaystyle\frac{n(n - 1)(n - 2)\cdots(n - k + 1)}{k!} = \frac{n!}{k!(n - k)!}$ неупорядоченных наборов.
    \end{proof}
    Формула бинома Ньютона имеет вид:
    \[
        (a + b)^{n} = \binom{n}{0}a^{n} + \binom{n}{1}a^{n - 1}b + \ldots + \binom{n}{k}a^{n - k}b^{k} + \ldots + \binom{n}{n}b^{n} = \sum_{k = 0}^{n}\binom{n}{k}a^{n - k}b^{k}
    \]
    \begin{proof}
        Раскрытие скобок даст все возможные комбинации $a$ и $b$ длины $n$. Так как умножение коммутативно, то элементы с одинаковым количеством $b$ можно сгрупировать. Тогда перед $a^{n - k}b^{k}$ будет стоять коэффициент $c$. Количество слогаемых, в которых $b$ встречается ровно $k$ раз равно $\displaystyle\binom{n}{k}$. Тогда $c = \displaystyle\binom{n}{k}$, а значит:
        \[
            (a + b)^{n} = \sum_{k = 0}^{n}\binom{n}{k}a^{n - k}b^{k}
        \]
    \end{proof}
    \pagebreak % временно
	
	\section*{3. Основные свойства треугольника Паскаля}
	
	
 	\section*{5. Доказательство формулы включений и исключений}
 	\begin{defin} [Формула включений и исключений.] Формула включений-исключений — комбинаторная формула, позволяющая определить мощность объединения конечного числа конечных множеств, которые в общем случае могут пересекаться друг с другом.
 	\end{defin}
 	\begin{state}
		Пусть $ A_{1}, A_{2},\ldots , A_{n} $ — конечные множества. Формула включений-исключений утверждает:
		$$\biggl | \bigcup_{i=1}^{n}A_i \biggl | =
		 \sum_{i} | A_i | - \sum_{i<j} | A_i \cap A_j | + \sum_{i<j<k} | A_i \cap A_j \cap A_k | - \ldots + (-1)^{n-1} | A_1 \cap A_2 \cap \ldots \cap A_n |.$$
 	\end{state}

 	\begin{proof}
	 	Рассмотрим произвольный элемент $x \in \biggl | \bigcup_{i=1}^{n}A_i \biggl |$, входящий в ровно $S$ множеств $A_{q_1}, ... A_{q_S}$ и подсчитаем, сколько раз он учитывается в правой части формулы включений-исключений (вернее покажем, что учитывается ровно 1 раз):
	 		\begin{itemize}
	 			\item В первой сумме $\sum_{i} | A_i |$ элемент  $x$ посчитан ровно ${S \choose 1} = S$ раз (В слагаемых $A_{q_1}, ... A_{q_S}$).

	 			\item Во второй сумме $\sum_{i<j} | A_i \cap A_j |$ элемент $x$ посчитан ровно ${S \choose 2}$ раз (количесво попарных пересечений $A_i \cap A_j$, таких, что $A_i, A_j \in A_{q_1}, ... A_{q_S}$).

	 			\item В третьей сумме $\sum_{i<j<k} | A_i \cap A_j \cap A_k |$ $x$ будет посчитан ${S \choose 3}$ раза (количество пересечений $A_i \cap A_j \cap A_k$ для которых $i, j \in q_1, \ldots q_S$).

	 			...

	 			\item В $S$-ой сумме $\sum_{i_1<i_2<\ldots<i_S} | A_{i_1} \cap A_{i_2} \cap \ldots \cap A_{i_S} |$
	 			$x$ будет посчитан ${S \choose S} = 1$  раз ($x$ войдет только в слагаемое $| A_1 \cap A_2 \cap \ldots \cap A_n |$).

	 			\item суммы, содержащие $S + 1$ и более пересечений, не учитывают элемент $x$, поскольку $x$ не входит в пересечение более чем $S$ множеств.
	 		\end{itemize}

	 		Таким образом $x$ оказывается посчитанным ровно $S - {S \choose 2} + {S \choose 3} - \ldots + (-1)^{S + 1} {S \choose S}$ раз. Покажем, что эта сумма в точности равна 1. Воспользуемся биномом Ньютона:

	 		$$0 = (1 - 1)^S =
	 		\sum_{k = 0}^{S} {S \choose k} \cdot 1^{S - k} \cdot (-1)^{k} =
	 		1 - \sum_{k = 1}^{S} {S \choose k} \cdot 1^{S - k} \cdot (-1)^{k + 1}$$

	 		$$\Updownarrow$$
	 		$$1 = \sum_{k = 1}^{S} {S \choose k} \cdot (-1)^{k + 1} =
	 		S - {S \choose 2} + {S \choose 3} - \ldots + (-1)^{S + 1} {S \choose S}$$

	 		Таким образом, каждый $x \in \biggl | \bigcup_{i=1}^{n}A_i \biggl |$ учитывается и левой и правой частью формулы ровно 1 раз, и очевидно, что все прочие $y \notin \biggl | \bigcup_{i=1}^{n}A_i \biggl |$ не учитываются ни правой, ни левой частями.
 	\end{proof}


    \section*{6. Формулы для суммы степеней вершин в неориентированном и в ориентированном графе}

    \begin{defin}
        Сумма степеней всех вершин в неориентированном графе равна удвоенному числу ребер. $\displaystyle\sum_{v \in V(G)} \deg(v) = 2 \cdot |E(G)|$
    \end{defin}
    \begin{proof}
        Пусть в графе степень каждой вершины равна $0$ (в графе нет ребер). При добавлении ребра, связывающего любые две вершины, сумма всех степеней увеличивается на 2 единицы. Таким образом, сумма всех степеней вершин четна и равна удвоенному числу ребер.
    \end{proof}
    \begin{defin}
        Число исходящих степеней вершин равно числу входящих, равно числу ребер.
    \end{defin}
    \begin{proof}
        Первая часть утверждения очевидна. Каждое ребро выходит из одной вершины и входит в другую, поэтому каждое ребро дает одинаковый вклад в суммы исходящих и входящих степеней вершин. Для доказательства второй части утверждения докажем что число ребер равно числу исходящих степеней вершин. Исходящая степень вершины равна числу ребер, которые из нее выходят. Ребро не может выходить более чем из одной вершины, поэтому сумма исходящих степеней вершин равна числу ребер. По транзитивности отношения <<=>> число ребер равно также и сумме исходящих вершин.
    \end{proof}


	\section*{7. Нижняя оценка числа связных компонент в неориентированном графе}
	
	\begin{ther}
		Число компонент связности в графе не меньше, чем разность количества вершин и ребер
	\end{ther}
	
	\begin{proof}
		Докажем по индукции по вершинам. 
		
		\textit{База индукции}. При $n = 1$ граф состоит из одной вершины, которая является единственной компонентой связности в графе. Разность количества вершин и ребер равно 1, база доказана.
		
		\textit{Шаг индукции}. Пусть для всех графов на n вершинах выполняется эта оценка, добавим еще одну вершину и рассмотрим случай связи, при котором сумма количества компонент
		связности и количество ребер наименьшая: выберем такой граф на $n$ вершинах (C - количество
		компонент связности в этом графе, E - количество ребер в этом графе), чтобы в нем эта сумма
		была наименьшей и добавим к нему еще одну вершину. Заметим, что если связать новую вершину
		хотя бы одним ребром с k уже существовавшими компонентами связности, то количество ребер
		увеличится, как минимум, на k, а компонент связности станет на$ k - 1 $меньше, чем в графе на$ n$
		вершинах. (Если не связывать, то станет на одну больше, так как будет еще одна компонента
		связности, если связать компоненты связности, то они станут одной компонентой связности, то
		есть количество уменьшится на единицу.) Так как нужна наименьшая сумма, то нужно
		использовать, как можно меньше ребер: будем соединять вершину 1 ребром с каждой из k существовавших компонентов связности - ребер станет на k больше, а количество компонентов
		связности уменьшится на $k - 1$, то есть сумма компонентов связности и ребер нового графа будет
		такой: $(C + 1 - k) + (E + k) = C + E + 1$. Но $ C + E + 1 \geq V + 1 $ из $ C + E \geq V$. Значит для $n + 1$ 		оценка верна.
	\end{proof}

	

    \section*{10. Деревья -- это в точности минимально связные графы}
    \begin{proof}\ \\
        $[\Rightarrow]$ Докажем индукцией по числу вершин. База: для $n = 2$ существует лишь одно дерево, для которого утверждение очевидно. Предположим это для некоторого дерева $G_{n}$ на $n$ вершинах, в котором $n - 1$ ребро. Шаг для $n + 1$: добавляя одну вершину $u$, нужно связать её с графом $G_{n}$, то есть соединить с некоторыми вершинами. Если бы мы соединили её с двумя вершинами $v_{1}$ и $v_{2}$, то у нас в графе $G_{n+1}$ получился бы цикл, так как в $G_{n}$ уже существовал путь $v_{1}, a_{1}, a_{2},\ldots, a_{k}, v_{2}$, а значит в $G_{n+1}$ существует цикл $v_{1}, a_{1}, a_{2},\ldots, a_{k}, v_{2}, u, v_{1}$, а значит $G_{n+1}$ -- не дерево. Значит, при добавлении вершины мы можем добавить не более одного ребра (а для сохранения связности ещё и более 0), значит $G_{n+1}$ должен содержать $n - 1 + 1 = n$ рёбер, что означает, что предположение индукции выполнено и для $n + 1$.
        
        \noindent$[\Leftarrow]$ Для начала докажем что в связном графе не может меньше чем $n - 1$ ребро по индукции. База: для $n = 2$ граф на 2-ух вершинах, все очевидно. Шаг для $n + 1$: если для $n$ вершин утверждение верно, то для $n + 1$ вершины оно тоже будет верно, так как нужно связать добавленную вершину как минимум с одним ребром (то есть ребер станет не менее чем $n - 1 + 1 = n$). Пусть у нас есть связный граф на $n$ вершинах, с $n - 1$ ребрами и в этом графе есть циклы. Из некоторого цикла удалим ребро соединявшее вершины $u$ и $v$, при этом граф останется связным, но в нем будет уже $n - 2$ ребра -- получили противоречие. Значит в таком минимально связном графе нет циклов, то есть этот граф -- дерево.
    \end{proof}

	\section*{11. Деревья - это в точности связные графы с $n - 1$ ребром}
	\begin{proof}
		Докажем в обе стороны.
		
		$\Rightarrow$. Докажем по индукции по вершинам.
		
		\textit{База индукции}. Для $n = 2$ существует в точности одно дерево, для которого утверждение очевидно.
		
		\textit{Шаг инудкции}. Пусть есть дерево на $n$ вершинах, в котором в точности $n - 1$ ребро. Если мы добавим в него вершину, нам необходимо будет ее связать с графом. Если мы проведем из нее больше одного ребра мы получим цикл, так как между проведенными вершинами существовал единственный путь. Добавлением двух ребер мы замкнули цикл, а значит мы не можем добавить больше одного ребра. Тогда получается, мы можем добавить в точности одно ребро, а значит и число ребер увеличилось на один, а значит и утверждение доказано.
		
		$\Leftarrow$. См. пункт 10.
		
		
	\end{proof}
	
	
    \pagebreak % временно
 	\section*{13. Существование остовного дерева}
 	\begin{defin} \textbf{Частичный граф} исходного графа 
 		$G = (V, E)$ — граф $G^{\prime} = (V, E^{\prime})$, $E^{\prime} \subseteq E$.
	\end{defin}

	\begin{defin} \textbf{Остовное дерево} связного графа $G = (V, E)$ — всякий его частичный граф, являющийся деревом.
	\end{defin}

	\begin{Lemma} 
		Если граф связен, то у него есть остовное дерево. 
	\end{Lemma}

	\begin{proof}
	Для начала докажем вспомогательную лемму:
		\begin{Lemma} Если граф связен и содержит хотябы один цикл, то из него можно удалить ребро не нарушая связности. 
		\end{Lemma}

		\begin{proof}[Доказательство леммы]
		Пусть $ G = (V, E) $ и цикл в нем: $ u_0 \rightarrow u_1 \rightarrow ... u_n \rightarrow u_0,\ u_i \in V$. Поймем, что если удалить любое ребро принадлежащее цикул, связность не нарушится. Покажем в частности, что можно удалит ребро $(u_0, u_1)$. Действительно, если есть какой-нибудь путь из $v  \in V$ в $w \in V$, проходящий через ребро $ (u_0,\ u_1) $, то существует путь проходящий через прочие ребра цикла, ведь в цикле до каждой вершины можно дойти хотя бы двумя разными путями, значит удаление ребра не изменит того факта, что $v$ соединено путем с $w$. Если пути из $v$ к $w$ не содержат ребра $(u_0, u_1)$, то очевидно, что его удаление на их связи не отразится $\Rightarrow$ граф без этого ребра останется связанным. Тогда удалим его и получим связный граф.
		\end{proof}

		Пусть тепереь $G = (V,\ E)$ - связный граф, для которого нужно доказать существование остовног дерева. Возможны два сценария:
			\begin{enumerate} 
			\item Граф $G$ - связный граф без циклов.
			\item В графе $G$ есть хотя бы один цикл. 
			\end{enumerate}

		В первом случае $G$ - дерево по определению, а значит сам является своим остовным деревом.

		Во втором случае, по доказанной лемме, мы можем удалить из $G$ ребро не нарушая связности. Так сделаем же это. Если полученный граф - цикличен, то снова удалим ребро не нарушая связности, иначе остановимся и порадуемся; индуктивно будем повторять описанные операции, на каждой иттерации имея связный граф; число ребер в графе - конечно, значит процесс не может продолжаться вечно $\Rightarrow$ в какой-то момент мы не сможем удалить ребро не нарушая связности, что было бы не возможно, если бы в графе остался цикл. В ходе описанных операций мы не добавляли новых ребер и не удаляли вершин $\Rightarrow$ если  $G^{\prime} = (V^{\prime},\ E^{\prime})$ - итоговый граф, то $V^{\prime} = V$, $E^{\prime} \subseteq E$ $\Rightarrow$ $G^{\prime}$ - частичный граф графа $G$, связный и без цилов, т.е. дерево $\Rightarrow$ $G^{\prime}$ по определению - остовное дерево графа $G$.
	\end{proof}

	\section*{15. Критерий существования эйлерова цикла в орграфе}
	\begin{ther}
		Орграф содержит эйлеров цикл тогда и только тогда, когда он сильно связен и у любой вершины входящая степень равна степени исходящей.
	\end{ther}
	
	\begin{proof}
		
		$\Rightarrow$. Пусть эйлеров цикл есть. Тогда он проходит через все вершины и по нему можно пройти от любой вершины до любой другой, а значит, он сильно связен.
		
		Возьмем произвольную вершину $v$ в графе и пусть она встречается в цикле $k$ раз. Тогда, идя по циклу, мы придем в нее $k$ раз и уйдем из нее $k$ раз. При этом, так как цикл эйлеров, мы должны пройти все ребра, а значит мы должны выйти и войти в вершину одинаковое количество раз. Значит, входящая и исходящая степени равны.
		
		
		$\Leftarrow$. Будем рассматривать пути, которые не проходят дважды по одному ребру. (Таков,
		например, путь, состоящий из одного ребра) Выберем среди них самый длинный путь
		$a_1 \rightarrow a_2 \ldots a_n$ и покажем, что он является искомым циклом, то есть что
		$a_1 = a_n$ и что он содержит все рёбра.
		Если он самый длинный, то добавить к нему ребро $an \rightarrow a_{n+1}$ уже нельзя, то есть все
		выходящие из an рёбра уже использованы (иначе мы нашли бы длиннее). Это возможно,
		лишь если $a_1 = a_n$. Почему? В самом деле, если вершина $a_n$ встречалась только внутри
		пути(то есть не являлась началом пути) (пусть она входит k раз внутри пути и ещё раз в
		конце пути), то мы использовали $k + 1$ входящих рёбер и k выходящих, и больше
		выходящих нет(путь самый длинный).
		Это противоречит равенству входящей и исходящей степени.
		Если во всех вершинах цикла использованы все рёбра,
		то из вершин этого цикла нельзя попасть вне цикла, то есть использованы все вершины
		(мы предполагаем, что граф связен или сильно связен) и, следовательно, все рёбра.
		Если из какой-то вершины $a_i$ выходит ребро $a_i \rightarrow v$, то путь можно удлинить до
		$a_i \rightarrow a_{i+1} \rightarrow \ldots \rightarrow a_n = a_1 \rightarrow a_2 \rightarrow \ldots \rightarrow a_i \rightarrow v$, вопреки нашему выбору (самого
		длинного пути). Если в какую-то вершину $a_i$ входит ребро $v \rightarrow a_i$, добавим $v$ в начало,
		тем самым удлинив путь, что опять же противоречит нашему выбору самого длинного
		пути.
	\end{proof}
	
	
	\section*{17. Сравнение $ax \equiv 1\ (mod\ N)$ имеет решение тогда и только тогда, когда $(a, N) = 1$}
		\begin{Note} Здесь и далее условимся обозначать НОД$(a, N)$, как $(a,\ N)$.
		\end{Note}
		\begin{state}
		Сравнение $ax \equiv 1\ (mod N)$ имеет решение $(1)$ $\Leftrightarrow$ $(a, N) = 1$ $(2)$. 
		\end{state}
		\begin{proof}
		Докажем следствие $(1) \Rightarrow (2)$
		$$ax - 1\equiv 0\ (mod\ N)$$ 
		$$\Downarrow$$ 
		$$N | (ax - 1)$$
		$$\Downarrow$$ 
		$$(ax - 1) = Nk,\ k \in Z.$$

		Пусть $(a,\ N) = b$ ($1 \leqslant b$, т.к. 1 - всегда делитель).
		Тогда $a = a\p \cdot b$, $N = N\p \cdot b$ $\Rightarrow$
		$$a\p bx - 1 = N\p bk$$
		$$\Downarrow$$
		$$1 = b(a\p x - N\p k)$$

		По определению $b|1$, но тогда $|b| \leqslant 1$, но тогда $b = 1$ $\Rightarrow$$(a,\ N) = 1$.

		Докажем следствие $(2) \Rightarrow (1)$: $(2) \Rightarrow (a,\ N) = 1$, тогда по соотношению Безу $\exists m,\ k:\ am + Nk = 1 \Rightarrow am = 1 - Nk \Rightarrow$ $am \equiv 1\ (mod\ N)$, и $x=m$ - решение сравния $ax \equiv 1\ (mod\ N)$.  
		\end{proof}

		\section*{18. Признаки делимости на 3, 9 и 11}

        Число $x$ делистся на $3$ (на $9$) тогда и только тогда, когда сумма его цифр делится на $3$ (на $9$)
        \begin{proof}
            Пусть $x = \overline{a_{n}a_{n - 1}\ldots a_{1}a_{0}} = 10^{n}a_{n} + 10^{n - 1}a_{n - 1} + \ldots + 10a_{1} + a_{0}$. Так как\\
            $10 \equiv 1 \pmod 3$, то:
            \[
                x \equiv \sum_{i = 0}^{n} a_{i} \pmod 3
            \]
            Для делимости на $9$ доказательство аналогично.
        \end{proof}
        Число $x$ делится на $11$, тогда и только тогда, когда:
        \[
        	11 | \bigg(\sum_{2 \mid i}^{n} a_{i} - \sum_{2 \nmid i}^{n} a_{i}\bigg)
        \]
        \begin{proof}
        	$10 \equiv -1 \pmod{11}$, значит $10^{n} \equiv (-1)^{n} \pmod{11}$. Тогда:
        	\[
        		x \equiv (-1)^{n}a_{n} + (-1)^{n - 1}a_{n - 1} + \ldots + (-1)a_{1} + a_{0} \equiv \sum_{2 \mid i}^{n} a_{i} - \sum_{2 \nmid i}^{n} a_{i} \pmod{11}
        	\]
        \end{proof}


		\section*{19. Малая теорема Ферма и лемма Вильсона}
		\begin{ther}
			Пусть $p$ - простое и $a$, такое, что оно не делится на $p$. Тогда утверждается, что 
			\[
				a^{p - 1} \equiv 1 \ (mod \ p)
			\]
		\end{ther}
	
		\begin{proof}
			Сперва докажем следующую лемму: Умножение остатков $1, 2, 3, \ldots , p - 1$
			на $a$ даст те же остатки, но в другом порядке.
			\textit{Доказательство от противного}. Пусть нашлись каких-то два числа $ax$ и $ay$, дающих одинаковый
			остаток при делении на $p$ ($x$ и $y$ — остатки). Тогда $a(x - y)$ делится на $p$, что невозможно. Тогда
			нет совпадающих остатков. Так как произведений, как и остатков, $p - 1$, то лемма верна.
			
			
			Рассмотрим произведения $a, 2a, 3a, \ldots, (p - 1)a$. Тогда
			\[
			a \cdot 2a \cdot \ldots \cdot (p-1)a \equiv a^{p - 1}(p - 1)! \ (mod \ p)
			\]
			С другой стороны, по лемме это эквивалентно $(p - 1)!$ по модулю $p$. Тогда $a^{p-1} \equiv 1 \ (mod \ p)$, что и
			требовалось доказать.
		\end{proof}
		
		
		\section*{21. Корректность алгоритма Евклида и расширенного алгоритма Евклида.}
		\begin{Evc}
		Пусть $a$ и $b$ - целые числа одноверемненно не равные нулю, и последовательность чисел
		$ x_0 > x_1 > x_2 > x_3 \cdots > x_n > 0$
		определена тем, что $x_0 = a,\ x_1 = b$, каждое $x_k,\ k > 1$ — это остаток от деления предпредыдущего числа на предыдущее, а предпоследнее делится на последнее нацело, то есть:
		$$a = x_0q_1 + x_1,$$
		$$b = x_1q_2 + x_2,$$
		$$x_2 = x_3q_3 + x_4,$$
		$$\cdots$$
		$$x_{k-2} = x_{k-1} q_{k-1} + x_k,$$	 
		$$\cdots$$
		$$x_{n-2} = x_{n-1}q_{n-1}+ x_n,$$
		$$x_{n-1} = x_n q_n.$$
		Тогда $(a, b)$ равен $x_n$, последнему ненулевому члену этой последовательности.
		\end{Evc}
		\begin{proof}
			Поймем, что такие $r_1, r_2, r_3, r_4, \cdots r_n$ - существуют, причем единственно: всегда можно найти остаток $m$ (причем единственным образом) при делении $r_k$ на $r_{k + 1}$, если $r_{k + 1} \ne 0$, причем $a > b > r_k > r_{k + 1} > m$, т.е. каждый следующий член последовательности строго меньше предыдущего, но т.к. числа ее составляющие - целые, то убывать бесконечно она не может, а значит $\exists x_{n + 1} = 0$ - последний член последовательности.

			Докажем тогда, что если $x_n$ - последний не нулевой член последовательности, то $(a, b) = (x_n, 0) = x_n \ne 0$. Для этого заметим две вещи:
			\begin{enumerate}
				\item $r \ne 0 \Rightarrow (r, 0) = |r|$ так как 0 делится на любое целое число, кроме нуля.

				\item Пусть $a = bq + r$, тогда $(a,\ b) = (b,\ r)$.
				Пусть $k$ — любой общий делитель чисел $a$ и $b$, не обязательно наибольший, тогда $a = t_1k$ и $b = t_2k$, где $t_1$ и $t_2$ — целые числа из определения.

				Тогда $k$ является также общим делителем чисел $b$ и $r$, так как $b$ делится на $k$ по определению, а $r = a - b\cdot q = (t_1 - t_2\cdot q)\cdot k$ (выражение в скобках есть целое число, следовательно, $k$ делит $r$ без остатка). 
				
				Обратное также верно. Любой делитель $k$ чисел $b$ и $r$ так же является делителем $a$ и $b$: $a = b \cdot q + r = k\cdot (b\p q + r\p)$$\Rightarrow$ $k|a$.
				
				Следовательно, все общие делители пар чисел $a$, $b$ и $b$, $r$совпадают. Другими словами, нет общего делителя у чисел $a$, $b$, который не был бы также делителем $b$, $r$, и наоборот.
				
				В частности, наибольший общий делитель остается тем же самым. Что и требовалось доказать.
			\end{enumerate}

			Тогда по построению последовательности $\{x_i\}: (x_0,\ x_1) = (x_1,\ x_2) = (x_2,\ x_3) = \ldots = (x_n,\ 0) = x_n$.
		\end{proof}
		\begin{Evc}[Расширенный алгоритм Евклида] 
			Формулы для $x_i$ могут быть переписаны следующим образом:
			$x_0 = aq_0 + bp_0$,
			$x_1 = aq_1 + bp_1$,
			$x_2 = aq_2 + bp_2$
			$x_3 = aq_3 + bp_3$
	 		$\vdots$
			$(a,\ b) = x_n = as + bt$
		\end{Evc}
		\begin{proof}
			Докажем по индукции по $n$. 

			\textit{База.} $x_0 = a + b \cdot 0$, $x_1 = a \cdot 0 + b$. Т.е. $q_0 = P_1 = 1,\ p_0 = q_1 = 0$

			\textit{Предположение.} Пусть $x_{k - 2} = aq_{k - 2} + bp_{k - 2}$ и $x_{k - 1} = aq_{k - 1} + bp_{k - 1}$.

			\textit{Шаг.} Докажем, что $x_k = aq_{k} + bp_{k}$, где $q_k,\ p_k$ - целые. Мы помним, что $x_k$ - остаток от деления $x_{k - 2}$ на $x_{k - 1}$, значит по определнию: $m\cdot x_{k - 1} + x_k = x_{k - 2}$, где $m$ - какое-то целое число. Тогда $x_k = x_{k - 2} - m \cdot x_{k - 1}$, по п.и., $x_k = aq_{k - 2} + bp_{k - 2} - m(aq_{k - 1} + bp_{k - 1}) = a(q_{k - 2} - mq_{k - 1}) + b(p_{k - 2} - mp_{k - 1}) = aq_{k} + bp_{k}$.

			Таким образом каждое из чисел $x_i$ представимо в виде линейной комбинации $a$ и $b$ (В частности, если $(a,\ b) = 1$, то $\exists x,\ y: ax + by = 1$).
		\end{proof}

\end{document}
