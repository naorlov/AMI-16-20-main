\documentclass[a4paper,12pt]{article}

\usepackage{header}
\usepackage{dsfont}

\newcommand {\gu} [1] {\guillemotleft#1\guillemotright}
\renewcommand{\Pr} {\text {Pr}}
\newcommand{\tab}{\quad\=}
\newenvironment{programm}{
    \ttfamily
    \smallskip
    \begin{tabbing}
    }
    {
    \end{tabbing}
    \smallskip
}


\begin{document}
	\title{Дискретная математика. Коллоквиум весна 2017. \\ Задачи}
    \author{Орлов Никита, Тимофей Гутор, Данила Усачёв, Иван Петровский, Андрей Ткачев}
	\maketitle
	
	\section*{Задача 4}
	О событиях $A$ и $B$ вероятностного пространства $U$ известно, что $\Pr [A]$ = $\Pr [B] = 4/5$. Могут ли при этом события $A\cup B$ и $B$ быть независимыми?
	
	\subsection*{Решение}
	Пусть вероятностное пространство $U$ задано таким образом, что любой исход на нём --- число от $0$ до $4$, событие $A$: \gu{число не равно 0} и $B$: \gu{число не равно 1}. Очевидно, что вероятность каждого из этих событий в отдельности равна $4/5$. Событию $A\cup B$: \gu{число не равно 0 \textit{или} число не равно 1} удовлетворяют все исходы. Таким образом, выполнено равенство $\Pr [A\cup B]\cdot\Pr [B]=1\cdot\Pr [B] = \Pr[B]$, то есть события $A\cup B$ и $B$ являются независимыми.
	
	\sep
	\section*{Задача 18}
	Постройте вычислимую биекцию между множествами $\N$ и $\N\,\backslash\,\{p^2\,|\,p\in\N\}$.
	\subsection*{Решение}
	Сначала определим разрешающую функцию второго множества $f(n)$:
    \begin{programm}
    \tab i = 0\\
    \tab while (i * i ) < n\\
    \tab\tab i = i + 1\\
    \tab return (i * i == n)
    \end{programm}
    Теперь рассмотрим отображение $g(x): \N\to\N\,\backslash\,\{p^2\,|\,p\in\N\}$, заданное следующим образом:
	
    \begin{programm}
    \tab i = 0\\
    \tab j = 0\\
    \tab while (i != n)\\
    \tab\tab while (f(j))\\
    \tab\tab\tab j = j + 1\\
    \tab\tab i = i + 1\\
    \tab return j
    \end{programm}
	
	Данное отображение сопоставляет числу $x$ элемент множества $\N\,\backslash\,\{p^2\,|\,p\in\N\}$, имеющий номер $x$ с начала в порядке возрастания (элементы $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ могут быть перечислены в порядке возрастания, так как оно разрешимо). Оно инъективно, так как элементы с различными номерами не равны (два различных элементы множества не равны). Также оно сюръективно, поскольку любой элемент $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ имеет некоторый номер, и для элемента из этого множества с номером $n$ прообразом будет число $n$. Таким образом, отображение $g$ биективно.
	\sep	
	
	\begin{comment}
	\section*{Задача 18}
    Постройте вычислимую биекцию между множествами $\N$ и $\N\,\backslash\,\{p^2\,|\,p\in\N\}$.
	\subsection*{Решение}
    Поскольку множество $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ разрешимо, его элементы могут быть перечислены в порядке возрастания (для этого перечисляющему алгоритму нужно последовательно идти по натуральным числам, начиная с 0, и, если текущее число входит в $\N\,\backslash\,\{p^2\,|\,p\in\N\}$, выводить его). Следовательно, элементы $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ могут быть пронумерованы натуральными числами. Тогда можно задать следующее отображение $f: \N\to\N\,\backslash\,\{p^2\,|\,p\in\N\}$: элементу $x\in\N$ сопоставляется элемент $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ с номером $n$. Это отображение инъективно, так как элементы с различными номерами не равны (два различных элементы множества не равны). Также оно сюръективно, поскольку любой элемент $\N\,\backslash\,\{p^2\,|\,p\in\N\}$ имеет некоторый номер, и для элемента из этого множества с номером $n$ прообразом будет число $n$. Таким образом, отображение $g$ биективно.
    
	\sep
	
    \end{comment}
	
	\section*{Задача 19}
	Постройте вычислимую биекцию между множеством двоичных слов и натуральными числами.
	\subsection*{Решение}
	Выпишем в столбец все двоичные слова длины $1$, затем в ещё один столбец --- двоичные слова длины $2$, затем --- слова длины $3$, и так далее. Пронумеруем последовательно, начиная с $0$, сначала слова в первом столбце, затем, продолжая нумерацию, во втором, затем --- в третьем, и так далее. Нумерация будет выглядеть следующим образом: \bigskip\\
	{
	\boldmath
	\begin{tabular}{c c c c c}
	   0 : $0$  & 2 : $00$ & \phantom{1}6 : $000$ & 14 : $0000$ & \ldots\ldots\ldots\\
	   1 : $1$  & 3 : $01$ & \phantom{1}7 : $001$ & 15 : $0001$ & \ldots\ldots\ldots\\
	            & 4 : $10$ & \phantom{1}8 : $010$ & 16 : $0010$ & \ldots\ldots\ldots\\
	            & 5 : $11$ & \phantom{1}9 : $011$ & 17 : $0011$ & \ldots\ldots\ldots\\
	            &          & 10 : $100$           & 18 : $0100$ & \ldots\ldots\ldots\\
	            &          & 11 : $101$           & 19 : $0101$ & \ldots\ldots\ldots\\
	            &          & 12 : $110$           & 20 : $0110$ & \ldots\ldots\ldots\\
                &          & 13 : $111$           & 21 : $0111$ & \ldots\ldots\ldots\\
	            &          &                      & 22 : $1000$ & \ldots\ldots\ldots\\
	            &          &                      & 23 : $1001$ & \ldots\ldots\ldots\\
	            &          &                      & 24 : $1010$ & \ldots\ldots\ldots\\
	            &          &                      & 25 : $1011$ & \ldots\ldots\ldots\\
	            &          &                      & 26 : $1100$ & \ldots\ldots\ldots\\
	            &          &                      & 27 : $1101$ & \ldots\ldots\ldots\\
	            &          &                      & 28 : $1110$ & \ldots\ldots\ldots\\
	            &          &                      & 29 : $1111$ & \ldots\ldots\ldots\\
	      
	   \end{tabular}
	}
	\bigskip
	\\
	Построим отображение, которое ставит в соответствие натуральному числу $n$ двоичное слово, имеющее номер $n$ в данной нумерации. Заметим, что это отображение инъективно --- слова с различными номерами различны, так как слова в одном столбце различны по построению, а слова в различных столбцах имеют разную длину. Также оно сюръективно, поскольку каждому номеру соответствует некоторое двоичное слово, так как их бесконечно много, и они были пронумерованы последовательно (если какому-то номеру не соответствует двоичное слово, значит, либо пронумеровано конечное количество слов, либо какой-то номер был \gu{пропущен}). Таким образом, построенное отображение биективно.

	\sep	
		
		
	\section*{Задача 20}
	Пусть $f$ --- вычислимая биекция между $\N$ и $\N$. Докажите, что обратная биекция $f^{-1}$ также вычислима.

	
	\subsection*{Решение}
	Функция $f(x):\N\to\N$ --- вычислимое биективное отображение. Рассмотрим следующий алгоритм, принимающий на вход $x$:
	\begin{programm}
	\tab i = 0\\
	\tab while (f(i) != x)\\
	\tab\tab i = i + 1\\
	\tab return i
	\end{programm}
    Этот алгоритм, очевидно, на входе $x$ вернёт значение $i$, на котором $f$ принимает значение $x$, то есть $f^{-1}(x)$. Также цикл {\ttfamily while} совершит ровно $i$ итераций, то есть конечное число, поскольку прообраз $x$ конечен. Таким образом, алгоритм остановится на любом входе за конечное число шагов, то есть соответствующая ему функция $f^{-1}$ вычислима.

	\sep		
	
	
	
	
	\section*{Задача 21}
    Докажите, что, если функция $f$ вычислима и $A \subset \N$ --- перечислимое множество, то и образ, и прообраз множетсва $A$ перечислимы.
	
	\subsection*{Решение}
	
    Докажем, что декартово произведение перечислимых множеств также перечислимо. Пусть множества $A$ и $B$ перечислимы, то есть для них существуют алгоритмы, с помощью которых могут быть получены все их элементы. Из этого следует, что элементы этих множеств могут быть пронумерованы в порядке, в котором они выводятся вышеназванными алгоритмами. Тогда для них существуют функции $f(x)$ и $b(x)$, сопоставляющие натуральному числу $x$ элементы $A$ и $B$ соответственно, имеющие в вышеобозначенной нумерации номер $x$ (если множество конечно, то для $x$, больших числа элементов в этом множестве, соответствующая функция не определена).  Предположим, что оба множества бесконечны. Тогда рассмотрим следующий алгоритм, принимающий на вход натуральное число $x$:
    \begin{programm}
    \tab a\_index = 0\\
    \tab b\_index = 0\\
    \tab number = 0\\
    \tab while (number != x)\\
    \tab \tab if (a\_index > 0)\\
    \tab \tab \tab a\_index = a\_index - 1\\
    \tab \tab \tab b\_index = b\_index + 1\\
    \tab \tab else\\
    \tab \tab \tab a\_index = b\_index + 1\\
    \tab \tab \tab b\_index = 0\\
    \tab \tab numder = number + 1\\
    \tab return (a[a\_index], b[b\_index])\\
    \end{programm}
	
	
	Докажем по индукции по $(i+j)$, что комбинация элементов ($a[i], b[j]$) будет выведена на входе $\frac{(i+j)(i+j+1)}2+j$. Заметим, что на входе $x$ цикл \texttt{while} совершает ровно $x$ итераций. База индукции --- $(i+j)=0$. Такому условию удовлетворяет только комбинация $(a[0], b[0])$, и несложно проверить, что она действительно будет выведена на входе $0$. Пусть теперь утверждение верно для всех комбинаций, для которых $(i+j)=k$. Докажем это для комбинаций, для которых $(i+j)=k+1$. По предположению индукции на входе $\frac{k(k+1)}2+k$ будет выведена комбинация $(a[0], b[k])$, то есть через $\frac{k(k+1)}2+k$ итерацию значениея \texttt{a\_index} и \texttt{b\_index} будут соответственно равны $0$ и $k$. Тогда на следующей итерации значения станут равны соответственно $k+1$ и $0$. Как мы знаем, цикл остановится на следующей итерации на входе $\frac{k(k+1)}2+k+1$, то есть $\frac{(k+1)(k+2)}2+0$. На следующем $k+1$ входе финальное значение \texttt{a\_index} будет каждый раз на $1$ уменьшатья, а \texttt{b\_index} --- увеличиваться, то есть на входе $\frac{(k+1)(k+2)}2+j$ будет выведена комбинация $(a[k+1-j], b[j])$ (при $j\geqslant k+1$, что и требовалось доказать.\\\\
	Теперь рассмотрим случай, в котором хотя бы одно из множеств конечно. Без ограничения общности предположим, что это множество $A$. Пусть количество его элементов равно $A\_size$. Тогда алгоритм, получающий все его элементы, совершает при этом конечное число шагов (так как для получения одного элемента он должен совершать конечное число шагов --- иначе этот элемент никогда не будет получен). В таком случае рассмотрим следующий алгоритм, принимающий на вход натуральное число $x$:
	\begin{programm}
    \tab a\_index = 0\\
    \tab b\_index = 0\\
    \tab number = 0\\
    \tab while (number != x)\\
    \tab \tab if (a\_index < A\_size)\\
    \tab \tab \tab a\_index = a\_index + 1\\
    \tab \tab else\\
    \tab \tab \tab a\_index = 0\\
    \tab \tab \tab b\_index = b\_index + 1\\
    \tab \tab number = number + 1\\
    \tab return (a[a\_index], b[b\_index])\\
	\end{programm}
	
	Этот алгоритм выведет комбинацию $(a[i], b[j])$ на входе $j\cdot A\_size + i$ (в предположении, что $i\leqslant A\_size$) Это несложно доказать: заметим, что каждые $A\_size$ итераций цикла \texttt{while} значение \texttt{a\_index} обнуляется, а \texttt{b\_index} увеличивается на $1$, в остальных же итерациях \texttt{a\_index} увеличивается на $1$, то есть финальное значение \texttt{a\_index} равно остатку при делении количества выполненных итераций на $A\_size$, а значение \texttt{b\_index} --- целой части при делении на $A\_size$. Количество же итераций, по аналогии с предыдущим описанным алгоритмом, равно входному значению. Заметим также, что бесконечность множества $B$ нигде не использовалась: если оно конечно, то вышеописанный алгоритм никогда не остановится на входах $j\cdot A\_size + i$, где $j > B\_size$, поскольку во время его работы будет вызвана невычислимая функция $b[j]$.\\\\
	Таким образом, выше было показано, что декартово произведение двух перечислимых множеств перечислимо. Докажем теперь, что, если функция $f$ вычислима и $A \subset \N$ --- перечислимое множество, то прообраз $A$ перечислим. Поскольку $A$ перечислимо, то и $A \times \N$ также перечислимо. Тогда существует алгоритм $\mathfrak{A}$, получающий все элементы этого множества. Рассмотрим алгоритм, который запускает $\mathfrak{A}$, и, получая некоторый элемент $(x, y)$, проверяет, является ли $x$ образом $y$ при отображении $f$, и, если это так, выводит $y$. Поскольку $x$ --- элемент $A$, то, что $x$ является образом $y$, означает, что $y$ входит в прообраз $A$, то есть вышеописанный алгоритм выводит только элементы $f^{-1}(A)$. Докажем, что он выведет все элементы $f^{-1}(A)$: если $m$ входит в $f^{-1}(A)$, существует $n$ такой, что $n\in A$ и $f(m)=n$. Поскольку $\mathfrak{A}$ получает все пары $(x, y)$, где $x \in A$ и $y \in \N$, за конечное число шагов, а функция $f$ вычислима (то есть алгоритм завершит \gu{обработку} любой полученной $\mathfrak{A}$ пары за конечное число шагов), пара $n, m$ также будет получена, а, поскольку $f(m)=n$, число $m$ будет выведено.\\\\
	Теперь докажем, что, если функция $f$ вычислима и $A \subset \N$ --- перечислимое множество, то образ $A$ также перечислимое множество. Поскольку $A$ перечислимо, существует некий алгоритм $\mathfrak{T}$, получающий все элементы $A$. Рассмотрим алгоритм, который запускает $\mathfrak{T}$ и, получая элемент $x$, выводит $f(x)$. Этот алгоритм, очевидно, выводит только элементы из $f(A)$. Также любой элемент $f(A)$ будет выведен через конечное число шагов, так как для любого $a\in f(A)$ существует $x\in A$ такое, что $a=f(x)$, $\mathfrak{T}$ получает любой элемент $A$ за конечное число шагов, а $f$ вычислима.
	
	\sep
	
	\section*{Задача 22}
	Найдите разрешимое множество $A$ и вычислимую функцию $f$ такие, что прообраз $f^{-1}(A)$ неразрешим.
	\subsection*{Решение}
	Пусть $K$ --- некоторое перечислимое, но неразрешимое множество, $k(x)$ --- функция, возвращающая $x$-ый по счёту вывод перечисляющего алгоритма $\mathfrak{A}$ для множества $K$. Тогда рассмотрим следующий алгоритм, принимающий на вход натуральное число $x$:
	\begin{programm}
	\tab i = 0\\
	\tab while (true)\\
	\tab \tab if (k(i) == x)\\
	\tab \tab \tab return 1\\
	\tab \tab i = i + 1\\
	\end{programm}
	
	Данный алгоритм, по сути, запускает внутри себя $\mathfrak{A}$, последовательно для каждого вывода $\mathfrak{A}$ проверяет, не равен ли данный вывод $x$, и в случае положительного ответа останавливается, выводя \gu{1} как результат своей работы. Поскольку для любого $k\in K$ алгоритм $\mathfrak{A}$ выводит $k$ через конечное число шагов, на входе $k$ вышеописанный алгоритм завершиться через конечное число шагов. На любом входе $p\not\in K$ алгоритм никогда не завершится, поскольку $p$ не является результатом работы $\mathfrak{A}$, и, следовательно, не принадлежит множеству значений $k(x)$. Функция $f$, вычисляемая приведённым выше алгоритмом, возвращает $1$ на элементах $K$ и не определена на $\N\,\backslash\,K$. Таким образом, $f^{-1}(\{1\})=K$, то есть $f$ и $\{1\}$ являются соответственно искомой функцией и искомым множеством.
<<<<<<< HEAD
    
	\section*{Задача 29}
    Приедите пример машины Тьюринга, вычисляющей нигде не определённую функцию.
    \subsection*{Решение}
    Рассмотрим машину Тьюринга, работающую на ленте с унарным алфавитом $\{a\}$ (любые входные данные могут быть представлены в унарной системе) и заданную следующим набором правил:
    \begin{center}
        \begin{tabular}{c||c|c}
            & {\boldmath $a$} &{\boldmath  $\Lambda$} \\
            \hline
            \hline
            {\boldmath $q_0$} & $q_0$, $a$, -1 & $q_0$, $\Lambda$, 1 \\
        \end{tabular}
    \end{center}
    Для неё возможны только две комбинации состояния и значения под считывающей головкой: $(q_0, a)$ и $(q_0, \Lambda)$. Для обоих этих состояний заданы правила, следовательно, машина никогда не остановится, и вычисляемая ею функция нигде не будет определена.
    
    \sep
    
    \section*{Задача 30}
    Постройте машину Тьюринга, находящую неполное частное от деления на $3$ в унарной системе.
    \subsection*{Решение}
    
    Пусть машина Тьюринга в начале своей работы находится в конфигурации $\langle \Lambda, q_0, x\rangle$ (где $x$ --- входные данные в унарной системе) и задаётся следующим набором правил:
    \begin{center}
        \begin{tabular}{c||c|c|c|c}
            \boldmath & \boldmath $1$ & \boldmath $a$ & \boldmath $b$ & \boldmath $\Lambda$ \\
            \hline
            \hline
            \boldmath $q_0$ & $b, q_1, 1$ & & & $q_3, \Lambda, -1$\\
            \boldmath $q_1$ & $b, q_2, 1$ & & & $q_3, \Lambda, -1$\\
            \boldmath $q_2$ & $a, q_0, 1$ & & & $q_3, \Lambda, -1$\\
            \boldmath $q_3$ & & $q_4, a, -1$ & $q_3, b, -1$ & \\
            \boldmath $q_4$ & & $q_4, a, -1$ & $q_7, a, 1$ & $q_9, \Lambda, 1$\\
            \boldmath $q_5$ & & $q_6, a, -1$ & $q_5, b, -1$ & \\
            \boldmath $q_6$ & & $q_6, a, -1$ & $q_7, a, 1$ & $q_8, \Lambda, 1$\\
            \boldmath $q_7$ & & $q_5, b, -1$ & & \\
            \boldmath $q_8$ & & $q_8, a, 1$ & $q_8, b, 1$ & $q_3, \Lambda, -1$\\
            \boldmath $q_9$ & & $q_9, a, 1$ & $q_9, b, 1$ & $q_{10}, \Lambda, -1$\\
            \boldmath $q_{10}$ & & $q_{10}, 1, -1$ & $q_{10}, \Lambda, -1$ & \\
        \end{tabular}
    \end{center}
    \gu{Программа} данной машины разделена на \gu{блоки}: $(q_0, q_1, q_2)$, $(q_3, q_4)$, $(q_5, q_6, q_7)$, $(q_8)$, $(q_9)$ и $(q_{10})$. Под этим понимается, что каждый блок выполняет свою отдельную задачу, и переход из одного блока означает, что задача текущего блока была выполнена. Под \gu{последовательностью} понимается слово от символа под считывающей головкой в изначальной конфигурации включительно до первого пустого символа справа не включительно.
    \begin{itemize}
        \item \textbf{Блок 1:} {\boldmath $(q_0, q_1, q_2)$} --- в этом блоке машина \gu{шифрует} входные данные таким образом, что на месте единиц с номерами, кратными $3$ (считая, что единица, изначально находившаяся под считывающей головкой, имеет номер 1) стоят символы \gu{$a$}, а на месте остальных --- \gu{$b$}. Выполнив этот блок, машина уже никогда к нему не возвращается, то есть при $i>2$ нет переходов из состояния $q_i$ в состояние $q_0$, $q_1$ или $q_2$. Дойдя до первого пустого символа, машина переходит в Блок 2.
        \item \textbf{Блок 2:} {\boldmath $(q_3, q_4)$} --- в этом блоке машина проходит по уже зашифрованной последовательности справа налево и проверяет, верно ли, что все символы \gu{$a$} стоят левее символов \gu{$b$}. Она начинает с состояния $q_3$, которое \gu{означает}, что справа от положения машины --- некоторое количество символов \gu{$b$}, затем --- пустой символ. Как только под считывающей головкой оказывается символ \gu{$a$}, машина переходит в состояние $q_4$, которое \gu{означает}, что справа от неё идёт некоторое количество символов \gu{$a$}, затем --- некоторое количество символов  \gu{$b$}, затем --- пустой символ. Как только машина в состоянии $q_4$ \gu{находит} символ \gu{$b$}, она переходит в Блок 3.
        \item \textbf{Блок 3:} {\boldmath $(q_5, q_6, q_7)$} --- в этом блоке машина выполняет одну итерацию сортировки пузырьком над частью последовательности, находящейся слева от начального положения машины при запуске переходе в Блок 3. В этом блоке машина работает так же, как и в Блоке 2 (состоянию $q_3$ соответствует $q_5$, а $q_4$ --- $q_6$), с той разницей, что, встретив в состоянии $q_6$ символ \gu{$b$}, машина просто меняет его с предыдущим символом (который равен  \gu{$a$}, что гарантируется состоянием $q_6$) и продолжает работу.
        \item \textbf{Блок 4:} {\boldmath $(q_8)$} --- в этот блок машина переходит из Блока 3, когда доходит до конца последовательности (до первого пустого символа). Выполняя Блок 4, машина проходит всю последовательность до её правого конца (то есть до первого пустого символа), ничего в ней не меняя, после чего переходит в Блок 2.
        \item \textbf{Блок 5:} {\boldmath $(q_9)$} --- в этот блок машина переходит из Блока 2, когда она доходит до конца последовательности (до первого пустого символа). Если это случилось, гарантируется, что последовательность не содержит подпоследовательностей \gu{$ba$} (иначе машина перешла бы из Блока 2 в Блок 3), то есть последовательность отсортирована. Выполняя Блок 5, машина проходит всю последовательность до её правого конца (то есть до первого пустого символа), ничего в ней не меняя, после чего запускает Блок 6. 
        \item \textbf{Блок 6:} {\boldmath $(q_{10})$} --- в этом блоке машина идёт по последовательности справа налево и стирает все встречающиеся символы \gu{$b$}, а символы \gu{$a$} заменяет на \gu{$1$}. При выполнении Блока 6 машина, дойдя до левого конца последовательности (то есть до первого пустого символа), останавливается, так как правила для комбинации $(q_{10}, \Lambda)$ нет.
    \end{itemize}
    
    Поскольку машина изначально заменяет на символ \gu{$a$} каждую третью единицу, их число как раз и является неполным частным при делении входного значения на 3. Таким образом, отсортировав последовательность так, что все символы \gu{$a$} стоят подряд (корректность пузырьковой сортировки можно считать общеизвестной), а затем заменив их на единицы, удалив всё остальное и остановившись слева от полученной унарной последовательности, машина получит как количество символов \gu{$a$} в зашифрованной исходной последовательности, которое, как было сказано выше, равно искомому неполному частному при делении входного значения на 3.
    
    \sep
    
    \end{document}
=======
>>>>>>> origin/master
	
	\sep
	
	\section*{Задача 29}
	Приедите пример машины Тьюринга, вычисляющей нигде не определённую функцию.
	\subsection*{Решение}
    Рассмотрим машину Тьюринга, работающую на ленте с унарным алфавитом $\{a\}$ (любые входные данные могут быть представлены в унарной системе) и заданную следующим набором правил:
    \begin{center}
    \begin{tabular}{c||c|c}
         & {\boldmath $a$} &{\boldmath  $\Lambda$} \\
         \hline
         \hline
        {\boldmath $q_0$} & $q_0$, $a$, -1 & $q_0$, $\Lambda$, 1 \\
    \end{tabular}
    \end{center}
    Для неё возможны только две комбинации состояния и значения под считывающей головкой: $(q_0, a)$ и $(q_0, \Lambda)$. Для обоих этих состояний заданы правила, следовательно, машина никогда не остановится, и вычисляемая ею функция нигде не будет определена.
    
    \sep
    
    \section*{Задача 30}
    Постройте машину Тьюринга, находящую неполное частное от деления на $3$ в унарной системе.
    \subsection*{Решение}
	
	Пусть машина Тьюринга в начале своей работы находится в конфигурации $\langle \Lambda, q_0, x\rangle$ (где $x$ --- входные данные в унарной системе) и задаётся следующим набором правил:
    \begin{center}
    \begin{tabular}{c||c|c|c|c}
    \boldmath & \boldmath $1$ & \boldmath $a$ & \boldmath $b$ & \boldmath $\Lambda$ \\
    \hline
    \hline
    \boldmath $q_0$ & $b, q_1, 1$ & & & $q_3, \Lambda, -1$\\
    \boldmath $q_1$ & $b, q_2, 1$ & & & $q_3, \Lambda, -1$\\
    \boldmath $q_2$ & $a, q_0, 1$ & & & $q_3, \Lambda, -1$\\
    \boldmath $q_3$ & & $q_4, a, -1$ & $q_3, b, -1$ & \\
    \boldmath $q_4$ & & $q_4, a, -1$ & $q_7, a, 1$ & $q_9, \Lambda, 1$\\
    \boldmath $q_5$ & & $q_6, a, -1$ & $q_5, b, -1$ & \\
    \boldmath $q_6$ & & $q_6, a, -1$ & $q_7, a, 1$ & $q_8, \Lambda, 1$\\
    \boldmath $q_7$ & & $q_5, b, -1$ & & \\
    \boldmath $q_8$ & & $q_8, a, 1$ & $q_8, b, 1$ & $q_3, \Lambda, -1$\\
    \boldmath $q_9$ & & $q_9, a, 1$ & $q_9, b, 1$ & $q_{10}, \Lambda, -1$\\
    \boldmath $q_{10}$ & & $q_{10}, 1, -1$ & $q_{10}, \Lambda, -1$ & \\
    \end{tabular}
    \end{center}
    \gu{Программа} данной машины разделена на \gu{блоки}: $(q_0, q_1, q_2)$, $(q_3, q_4)$, $(q_5, q_6, q_7)$, $(q_8)$, $(q_9)$ и $(q_{10})$. Под этим понимается, что каждый блок выполняет свою отдельную задачу, и переход из одного блока означает, что задача текущего блока была выполнена. Под \gu{последовательностью} понимается слово от символа под считывающей головкой в изначальной конфигурации включительно до первого пустого символа справа не включительно.
    \begin{itemize}
        \item \textbf{Блок 1:} {\boldmath $(q_0, q_1, q_2)$} --- в этом блоке машина \gu{шифрует} входные данные таким образом, что на месте единиц с номерами, кратными $3$ (считая, что единица, изначально находившаяся под считывающей головкой, имеет номер 1) стоят символы \gu{$a$}, а на месте остальных --- \gu{$b$}. Выполнив этот блок, машина уже никогда к нему не возвращается, то есть при $i>2$ нет переходов из состояния $q_i$ в состояние $q_0$, $q_1$ или $q_2$. Дойдя до первого пустого символа, машина переходит в Блок 2.
        \item \textbf{Блок 2:} {\boldmath $(q_3, q_4)$} --- в этом блоке машина проходит по уже зашифрованной последовательности справа налево и проверяет, верно ли, что все символы \gu{$a$} стоят левее символов \gu{$b$}. Она начинает с состояния $q_3$, которое \gu{означает}, что справа от положения машины --- некоторое количество символов \gu{$b$}, затем --- пустой символ. Как только под считывающей головкой оказывается символ \gu{$a$}, машина переходит в состояние $q_4$, которое \gu{означает}, что справа от неё идёт некоторое количество символов \gu{$a$}, затем --- некоторое количество символов  \gu{$b$}, затем --- пустой символ. Как только машина в состоянии $q_4$ \gu{находит} символ \gu{$b$}, она переходит в Блок 3.
        \item \textbf{Блок 3:} {\boldmath $(q_5, q_6, q_7)$} --- в этом блоке машина выполняет одну итерацию сортировки пузырьком над частью последовательности, находящейся слева от начального положения машины при запуске переходе в Блок 3. В этом блоке машина работает так же, как и в Блоке 2 (состоянию $q_3$ соответствует $q_5$, а $q_4$ --- $q_6$), с той разницей, что, встретив в состоянии $q_6$ символ \gu{$b$}, машина просто меняет его с предыдущим символом (который равен  \gu{$a$}, что гарантируется состоянием $q_6$) и продолжает работу.
        \item \textbf{Блок 4:} {\boldmath $(q_8)$} --- в этот блок машина переходит из Блока 3, когда доходит до конца последовательности (до первого пустого символа). Выполняя Блок 4, машина проходит всю последовательность до её правого конца (то есть до первого пустого символа), ничего в ней не меняя, после чего переходит в Блок 2.
        \item \textbf{Блок 5:} {\boldmath $(q_9)$} --- в этот блок машина переходит из Блока 2, когда она доходит до конца последовательности (до первого пустого символа). Если это случилось, гарантируется, что последовательность не содержит подпоследовательностей \gu{$ba$} (иначе машина перешла бы из Блока 2 в Блок 3), то есть последовательность отсортирована. Выполняя Блок 5, машина проходит всю последовательность до её правого конца (то есть до первого пустого символа), ничего в ней не меняя, после чего запускает Блок 6. 
        \item \textbf{Блок 6:} {\boldmath $(q_{10})$} --- в этом блоке машина идёт по последовательности справа налево и стирает все встречающиеся символы \gu{$b$}, а символы \gu{$a$} заменяет на \gu{$1$}. При выполнении Блока 6 машина, дойдя до левого конца последовательности (то есть до первого пустого символа), останавливается, так как правила для комбинации $(q_{10}, \Lambda)$ нет.
    \end{itemize}
    
    Поскольку машина изначально заменяет на символ \gu{$a$} каждую третью единицу, их число как раз и является неполным частным при делении входного значения на 3. Таким образом, отсортировав последовательность так, что все символы \gu{$a$} стоят подряд (корректность пузырьковой сортировки можно считать общеизвестной), а затем заменив их на единицы, удалив всё остальное и остановившись слева от полученной унарной последовательности, машина получит как количество символов \gu{$a$} в зашифрованной исходной последовательности, которое, как было сказано выше, равно искомому неполному частному при делении входного значения на 3.
    
    \sep

\end{document}
